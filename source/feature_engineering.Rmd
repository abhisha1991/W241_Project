## Feature Engineering

```{r, message=FALSE, echo=FALSE, warning=FALSE}
# Clean up the workspace before we begin
rm(list = ls());set.seed(1)

library(data.table)
library(lmtest)
library(sandwich)
library(stargazer)
library(dplyr)
library(DataExplorer)

# Insert the function to *tidy up* the code when they are printed out
library(knitr)
opts_chunk$set(tidy.opts=list(width.cutoff=60), tidy=TRUE)
``` 

```{r}
d_ori <- fread("data.csv", , na.strings=c("","NA"))

head(d_ori)
```

```{r}
# display number of columns
length(d_ori[0])
```

```{r}
# ResponseID is our primary key for the table as it is unique for each row and is guaranteed to be present
nrow(d_ori[, .(count=.N), by = list(ResponseID)]) == nrow(d_ori)
```


```{r}
d_ori[, .(count=.N), by = list(Finished)]
```

```{r}
d_ori[, .(count=.N), by = list(ResponseType)]
```

```{r Utility Functions}
# gets a row by the field "Name" in dataframe "data"
getRowByName <- function(name, data) {
  return (data[data$Name == name, ]) 
}

# gets a row by the field "TreatmentCol" in dataframe "data"
getRowByTreatmentCol <- function(num, data) {
  return (data[data$TreatmentCol == paste("TreatmentQ", num, sep=""), ]) 
}

# gets a row by the field "ControlCol" in dataframe "data"
getRowByControlCol <- function(num, data) {
  return (data[data$ControlCol == paste("ControlQ", num, sep=""), ]) 
}

# gets a row by the field "ResponseID" in dataframe "data"
getRowByResponseID <- function(responseId, data) {
  return (data[data$ResponseID == responseId, ]) 
}

# are all treatment questions NA (condition for participant being in control group)
areAllTreatmentQNA <- function(data, rowNum) {
  return (is.na(data[rowNum]$TreatmentQ1) & is.na(d[rowNum]$TreatmentQ2) & is.na(d[rowNum]$TreatmentQ3) &   is.na(d[rowNum]$TreatmentQ4) & is.na(d[rowNum]$TreatmentQ5) & is.na(d[rowNum]$TreatmentQ6))
}

# are all control questions NA (condition for participant being in treatment group)
areAllControlQNA <- function(data, rowNum) {
  return (is.na(data[rowNum]$ControlQ1) & is.na(d[rowNum]$ControlQ2) & is.na(d[rowNum]$ControlQ3) &   is.na(d[rowNum]$ControlQ4) & is.na(d[rowNum]$ControlQ5) & is.na(d[rowNum]$ControlQ6))
}

# gets number of treatment columns that are NA 
getSumTreatmentQNA <- function(data, rowNum) {
  
  someTreatmentNA = c(is.na(data[rowNum]$TreatmentQ1), is.na(d[rowNum]$TreatmentQ2),  is.na(d[rowNum]$TreatmentQ3), is.na(d[rowNum]$TreatmentQ4), is.na(d[rowNum]$TreatmentQ5), is.na(d[rowNum]$TreatmentQ6))
  
  return (sum(someTreatmentNA))
}

# gets number of control columns that are NA 
getSumControlQNA <- function(data, rowNum) {
  
  someControlNA = c(is.na(data[rowNum]$ControlQ1), is.na(d[rowNum]$ControlQ2), is.na(d[rowNum]$ControlQ3),   is.na(d[rowNum]$ControlQ4), is.na(d[rowNum]$ControlQ5), is.na(d[rowNum]$ControlQ6))
  
  return (sum(someControlNA))
}

# if all 12 columns of treatment and control are NA, then the row is invalid
# represents a likely non-complier (never taker)
isInvalidRow <- function(data, rowNum) {
  return(getSumControlQNA(data, rowNum) + getSumTreatmentQNA(data, rowNum) == 12)
}

# if person was assigned to either treatment or control, but didn't end up answering all questions
isAttritedRow <- function(data, rowNum) {
  cols = getSumControlQNA(data, rowNum) 
  result = (cols < 6 & cols > 0)
  if (result) {
    return (result)
  }
  
  cols = getSumTreatmentQNA(data, rowNum)
  result = (cols < 6 & cols > 0)
  return (result | isInvalidRow(data, rowNum))
}

# we cannot have some NA in both treatment and control
isInvalidTreatmentAssignment <- function(data, rowNum) {
  controlNa = getSumControlQNA(data, rowNum) 
  treatmentNa = getSumTreatmentQNA(data, rowNum)
  return ((controlNa > 0 & controlNa < 6) & (treatmentNa > 0 & treatmentNa < 6))
}

# generating random numbers from 1-5 for fake treatment/control responses
generateRandomIntNums <- function(n, mean, sd) {
  
  nums = mean + sd * scale(rnorm(n))
  # numbers must be 1-5
  for (i in 1:nrow(nums)) {
    
    # arbitrarily choose floor or ceiling for that number (since response must be integer)
    if(sample(c(0,1), size =1))  {
      nums[i] = ceiling(nums[i])
    }
    else {
      nums[i] = floor(nums[i]) 
    }
    
    # bound number between 1-7
    if(nums[i] < 1) {
      nums[i] = 1
    }
    
    if(nums[i] > 7) {
      nums[i] = 7
    }
  }
  
  return(nums[1:n])
}
```


```{r}
nameResumeBinding <- data.table(
  Name  = c("Bradley Meyer", "Reginald Washington", "Kirsten Schmidt", "Gwendolyn Jackson"),
  Race = c("White", "Black", "White", "Black"),
  Gender = c("Male", "Male", "Female", "Female"),
  RaceGender = c("WM", "BM", "WF", "BF"),
  ResumeId   = c(1, 2, 3, 4)
)
```

```{r}
treatmentBinding <- data.table(
  LeftName  = c("Bradley Meyer", "Bradley Meyer", "Bradley Meyer", "Kirsten Schmidt", "Reginald Washington", "Kirsten Schmidt"),
  RightName = c("Reginald Washington", "Kirsten Schmidt", "Gwendolyn Jackson", "Reginald Washington", "Gwendolyn Jackson", "Gwendolyn Jackson"),
  TreatmentCol = c("TreatmentQ1", "TreatmentQ2", "TreatmentQ3", "TreatmentQ4", "TreatmentQ5", "TreatmentQ6")
)


treatmentMetadata <- merge(treatmentBinding, nameResumeBinding, by.x = 'LeftName', by.y = 'Name')
setnames(treatmentMetadata, 4:7, paste0('Left', names(treatmentMetadata)[4:7]))
treatmentMetadata <- merge(treatmentMetadata, nameResumeBinding, by.x = 'RightName', by.y = 'Name')
setnames(treatmentMetadata, 8:11, paste0('Right', names(treatmentMetadata)[8:11]))
```

```{r}
controlBinding <- data.table(
  LeftResumeId  = c(1, 1, 1, 3, 2, 3),
  RightResumeId = c(2, 3, 4, 2, 4, 4),
  ControlCol = c("ControlQ1", "ControlQ2", "ControlQ3", "ControlQ4", "ControlQ5", "ControlQ6")
)

controlMetadata <- merge(controlBinding, nameResumeBinding, by.x = 'LeftResumeId', by.y = 'ResumeId')
setnames(controlMetadata, 4:7, paste0('Left', names(controlMetadata)[4:7]))
controlMetadata <- merge(controlMetadata, nameResumeBinding, by.x = 'RightResumeId', by.y = 'ResumeId')
setnames(controlMetadata, 8:11, paste0('Right', names(controlMetadata)[8:11]))
```

```{r Remove uncompleted data and survey preview & spam}
d <- d_ori[Finished=='TRUE' & ResponseType=='IP Address']
```

```{r}
# treatment and control assignment
n <- nrow(d)

# have valid columns for treatment assignment and attrition
d$TreatmentAssignment = NA
d$IsAttrited = NA
d$IsNeverTaker = NA

for (i in 1:n) {
  # row <- getRowByResponseID(d[i]$ResponseID, d)
  
  control <- areAllTreatmentQNA(d, i)
  treatment <- areAllControlQNA(d, i)
  isInvalid <- isInvalidRow(d, i)
  isAttrited <- isAttritedRow(d, i)
  isInvalidTreatmentAssigned <- isInvalidTreatmentAssignment(d, i)
  
  # print(c(control, treatment, isInvalid, isAttrited, isInvalidTreatmentAssigned))
  if (isInvalid | isInvalidTreatmentAssigned) {
    
    if (isInvalidTreatmentAssigned) {
      e = sprintf("Row %s has invalid treatment assignment", i)  
      stop(e)
    }
    
    if (isInvalid) {
      sprintf("Row %s has no responses in treatment and control columns", i)  
    }
    
    d[i]$TreatmentAssignment = NA
    
  }
  else {
    
    if (treatment & control) {
      e = sprintf("Both treatment and control are true! This should never happen! Error found in row %s", i)
      stop(e)
    }
    
    d[i]$TreatmentAssignment = treatment  
  }
  
  d[i]$IsAttrited = isAttrited
  d[i]$IsNeverTaker = isInvalid
  
  # special case, if we find attrition only, then we need to re-assign treatment  
  if (isAttrited & !(isInvalid | isInvalidTreatmentAssigned)) {
    
    numNa = getSumTreatmentQNA(d, i)
    treatment = numNa > 0 & numNa < 6    
    d[i]$TreatmentAssignment = treatment      
  
  }
}
```

```{r}
# There are 4 attrited records. Removed here.
d[, .(count=.N), by = list(IsAttrited)]
d <- d[IsAttrited==0]
```

```{r}
# We also check the average time people take to evaluate 6 pairs of resumes.
# FC: first click; LC: last click; PS: page submit; CC: click count

d <- d[,  AvgTime := as.double(.N)]

n <- nrow(d)
for (i in 1:n){
  if (d[i]$TreatmentAssignment == TRUE){
    d[i]$AvgTime <- (d[i]$TimePS_TreatmentQ1 + d[i]$TimePS_TreatmentQ2 + d[i]$TimePS_TreatmentQ3 + d[i]$TimePS_TreatmentQ4 + d[i]$TimePS_TreatmentQ5 + d[i]$TimePS_TreatmentQ6)/6
  }
  else {
    d[i]$AvgTime <- (d[i]$TimePS_ControlQ1 + d[i]$TimePS_ControlQ2 + d[i]$TimePS_ControlQ3 + d[i]$TimePS_ControlQ4 + d[i]$TimePS_ControlQ5 + d[i]$TimePS_ControlQ6)/6
  }
}

hist(d[TreatmentAssignment==0]$AvgTime, 
     breaks = 20, 
     main = 'Histogram for averge answering time for control group questions', 
     xlab='Averge answering time')

hist(d[TreatmentAssignment==1]$AvgTime, 
     breaks = 100, 
     main = 'Histogram for averge answering time for treatment group questions', 
     xlab='Averge answering time')

print('Median of averge answering time for control group questions')
median(d[TreatmentAssignment==0]$AvgTime)

print('Median of averge answering time for treatment group questions')
median(d[TreatmentAssignment==1]$AvgTime)
```

```{r}
# Averge answering time is relatively short.
# Here we remove any record with an average answering time less than 10 seconds.
d <- d[AvgTime>=10]
nrow(d)
```

```{r}
# Ratio of Treatment and Assignment
d[, .(count=.N), by = list(TreatmentAssignment)]
```

```{r}
# Proportion of missing values in covariates

plot_missing(d[, c('YearOfBirth', 'GenderCategory','Gender','IsEnglishFirstLanguage','Race','CountryOfResidence','StateOfResidence','RoleAtBerkeley','IsTransferStudent','YearsAtBerkeley','DidEarnMoneyLastYear','EmploymentStatus','IncomeIn2020','HighestDegreeReceived','PoliticalAffiliation','ReligiousAffliation','BookFormatPurchasedMostOften','FrequencySocialMediaAccess','FrequencySocialMediaPosting','ClassLevel','GenderCGSurvey','HasServedInCG','HasServedInAnyOtherUniformedService','PlaceboPreTestColleagueAffinity','PlaceboPostTestColleagueAffinity')])
```

We are going to remove last 5 variables that have too many missing values.

```{r}
# Covariate balance check (The only continuous variable: YearOfBirth)

# Check for outliers and abnormal values
unique(d$YearOfBirth)
```

There are outliers such as 25 and 2020, as well as abnormal values such as country names.

```{r}
# Remove outliers and abnormal values
d <- d[, YearOfBirth:=as.integer(YearOfBirth)]
d <- d[YearOfBirth<2015 & YearOfBirth>1950]

plot_density(d$YearOfBirth)
```

Most of respondents are around 20 years old.

```{r}
# Covariate balance check (Overall_categorical)
plot_bar(d[, c('GenderCategory','IsEnglishFirstLanguage','HighestDegreeReceived','Race','RoleAtBerkeley','DidEarnMoneyLastYear','EmploymentStatus','PoliticalAffiliation','ReligiousAffliation','BookFormatPurchasedMostOften','FrequencySocialMediaAccess','FrequencySocialMediaPosting','ClassLevel','GenderCGSurvey','HasServedInCG','HasServedInAnyOtherUniformedService','CountryOfResidence')], nrow=2, ncol=1)
```

Most of the respondents have never served in uniformed service before, so it is hard to say that their reply will reflect the actual situation in CG. Almost all respondents are from the States. Around 2/3 of the respondents are female, half of them are Asian. Roughly half of them are democrats, and only 5.3% of them are republicans. The main source of data is Xlab (undergraduate Berkeley students). 

```{r}
# Covariate balance check (Control_categorical)
plot_bar(d[TreatmentAssignment==0, c('GenderCategory','IsEnglishFirstLanguage','HighestDegreeReceived','Race','RoleAtBerkeley','DidEarnMoneyLastYear','EmploymentStatus','PoliticalAffiliation','ReligiousAffliation','BookFormatPurchasedMostOften','FrequencySocialMediaAccess','FrequencySocialMediaPosting','ClassLevel','GenderCGSurvey','HasServedInCG','HasServedInAnyOtherUniformedService','CountryOfResidence')], nrow=2, ncol=1)
```

```{r}
# Covariate balance check (Treatment_categorical)
plot_bar(d[TreatmentAssignment==1, c('GenderCategory','IsEnglishFirstLanguage','HighestDegreeReceived','Race','RoleAtBerkeley','DidEarnMoneyLastYear','EmploymentStatus','PoliticalAffiliation','ReligiousAffliation','BookFormatPurchasedMostOften','FrequencySocialMediaAccess','FrequencySocialMediaPosting','ClassLevel','GenderCGSurvey','HasServedInCG','HasServedInAnyOtherUniformedService','CountryOfResidence')], nrow=2, ncol=1)
```

The differnce between categorical variables in control and treatment group is small.

```{r}
# Ratio of Treatment and Assignment (After removal of outliers and abnormal data)
d[, .(count=.N), by = list(TreatmentAssignment)]
```

## Create Datasets to be used

```{r Utility Functions for Dataset Creation}
cols <- colnames(d)
coreColumns <- cols[!startsWith(cols, "TimeFC_") & !startsWith(cols, "TimeLC_") & !startsWith(cols, "TimePS_") & !startsWith(cols, "TimeCC_") & !startsWith(cols, "TreatmentQ") & !startsWith(cols, "ControlQ")]

getCoreColumnsDataset <- function() {
  return(d %>% select(one_of(coreColumns)))
}

getTreatmentDataset <- function(qNum) {
  treatmentqNum = paste("TreatmentQ", qNum, sep ="")
  treatmentSet = (d %>% select(one_of(coreColumns) | ends_with(treatmentqNum)))
  return (treatmentSet[TreatmentAssignment == TRUE, ])
}

getControlDataset <- function(qNum) {
  controlqNum = paste("ControlQ", qNum, sep ="")
  controlSet = (d %>% select(one_of(coreColumns) | ends_with(controlqNum)))
  return (controlSet[TreatmentAssignment == FALSE, ])
}
```

```{r}
dCore = getCoreColumnsDataset()

dTQ1 = getTreatmentDataset(1)
dTQ2 = getTreatmentDataset(2)
dTQ3 = getTreatmentDataset(3)
dTQ4 = getTreatmentDataset(4)
dTQ5 = getTreatmentDataset(5)
dTQ6 = getTreatmentDataset(6)

# sanity check to see all data sets are of the same size
nrow(dTQ1) == nrow(dTQ2)
nrow(dTQ2) == nrow(dTQ3) 
nrow(dTQ3) == nrow(dTQ4) 
nrow(dTQ4) == nrow(dTQ5) 
nrow(dTQ5) == nrow(dTQ6)

dCQ1 = getControlDataset(1)
dCQ2 = getControlDataset(2)
dCQ3 = getControlDataset(3)
dCQ4 = getControlDataset(4)
dCQ5 = getControlDataset(5)
dCQ6 = getControlDataset(6)

# sanity check to see all data sets are of the same size
nrow(dCQ1) == nrow(dCQ2)
nrow(dCQ2) == nrow(dCQ3) 
nrow(dCQ3) == nrow(dCQ4) 
nrow(dCQ4) == nrow(dCQ5) 
nrow(dCQ5) == nrow(dCQ6)
```

```{r}
# head(dTQ1)
```

### Assign Fake Treatment and Control Reponses (Optional)

>As we are aware, we had an error in the procedure around collecting data for our participants. Thus we will overwrite the data with fake responses so as to prove out our analysis methodology. Below we choose a `random number generator to generate responses from 1-5`. The rubric is as follows:

>`1: Strongly prefer left resume`

>`2: Prefer left resume`

>`3: Slightly prefer left resume`

>`4: Neutral (no preference on left or right resume)`

>`5: Slightly prefer right resume`

>`6: Prefer right resume`

>`7: Strongly prefer right resume`

```{r Generate Random Numbers And Assign to Response Column}

# We deliberately give fake treatment effects
dTQ1$TreatmentQ1 = generateRandomIntNums(nrow(dTQ1), 1, 2) # WM BM
dTQ2$TreatmentQ2 = generateRandomIntNums(nrow(dTQ2), 2, 1) # WM WF
dTQ3$TreatmentQ3 = generateRandomIntNums(nrow(dTQ3), 5, 1) # WM BF
dTQ4$TreatmentQ4 = generateRandomIntNums(nrow(dTQ4), 4, 1) # WF BM
dTQ5$TreatmentQ5 = generateRandomIntNums(nrow(dTQ5), 4, 1) # BM BF
dTQ6$TreatmentQ6 = generateRandomIntNums(nrow(dTQ6), 2, 1) # WF BF

# Note: means are typically underestimated
mean(dTQ1$TreatmentQ1)
mean(dTQ2$TreatmentQ2)
mean(dTQ3$TreatmentQ3)
mean(dTQ4$TreatmentQ4)
mean(dTQ5$TreatmentQ5)
mean(dTQ6$TreatmentQ6)

# We expect the control group to have no difference in left / right resumes (on average)
dCQ1$ControlQ1 = generateRandomIntNums(nrow(dCQ1), 3, 2)
dCQ2$ControlQ2 = generateRandomIntNums(nrow(dCQ2), 5, 2)
dCQ3$ControlQ3 = generateRandomIntNums(nrow(dCQ3), 6, 2)
dCQ4$ControlQ4 = generateRandomIntNums(nrow(dCQ4), 4, 1)
dCQ5$ControlQ5 = generateRandomIntNums(nrow(dCQ5), 4, 1)
dCQ6$ControlQ6 = generateRandomIntNums(nrow(dCQ6), 5, 1)

# Note: means are typically underestimated
print('---')
mean(dCQ1$ControlQ1)
mean(dCQ2$ControlQ2)
mean(dCQ3$ControlQ3)
mean(dCQ4$ControlQ4)
mean(dCQ5$ControlQ5)
mean(dCQ6$ControlQ6)
```

```{r Join Treatment and Control Tables with Metadata}

addTreatmentMetadataToDataset <- function(dt, treatmentNum) {
  
  row = getRowByTreatmentCol(treatmentNum, treatmentMetadata)
  
  dt$LeftName = row$LeftName
  dt$LeftPersonRace = row$LeftPersonRace
  dt$LeftPersonGender = row$LeftPersonGender
  dt$LeftPersonRaceGender = row$LeftPersonRaceGender
  dt$LeftPersonResumeId = row$LeftPersonResumeId
    
  dt$RightName = row$RightName
  dt$RightPersonRace = row$RightPersonRace
  dt$RightPersonGender = row$RightPersonGender
  dt$RightPersonRaceGender = row$RightPersonRaceGender
  dt$RightPersonResumeId = row$RightPersonResumeId
  
  return(dt)
}

addControlMetadataToDataset <- function(dt, controlNum) {
  
  row = getRowByControlCol(controlNum, controlBinding)
  dt$LeftResumeId = row$LeftResumeId
  dt$RightResumeId = row$RightResumeId
  
  return(dt)
}

dTQ1 = addTreatmentMetadataToDataset(dTQ1, 1)
dTQ2 = addTreatmentMetadataToDataset(dTQ2, 2)
dTQ3 = addTreatmentMetadataToDataset(dTQ3, 3)
dTQ4 = addTreatmentMetadataToDataset(dTQ4, 4)
dTQ5 = addTreatmentMetadataToDataset(dTQ5, 5)
dTQ6 = addTreatmentMetadataToDataset(dTQ6, 6)

dCQ1 = addControlMetadataToDataset(dCQ1, 1)
dCQ2 = addControlMetadataToDataset(dCQ2, 2)
dCQ3 = addControlMetadataToDataset(dCQ3, 3)
dCQ4 = addControlMetadataToDataset(dCQ4, 4)
dCQ5 = addControlMetadataToDataset(dCQ5, 5)
dCQ6 = addControlMetadataToDataset(dCQ6, 6)

```

```{r}
#head(dTQ1)
#head(dCQ1)
```


